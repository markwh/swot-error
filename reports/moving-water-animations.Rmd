---
title: "Connectivity Animations"
author: "Mark Hagemann"
date: "4/28/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



In the last week I've been indulged by my boss to develop an algorithm for selecting likely moving-water pixels out of detected-water pixels from a satellite image. I have two versions of the algorithm--one recursive and the other iterative. One in R, the other in Python. Here I'm going to use the **gganimate** package to illustrate the difference between the two. Both do the same thing, but their different natures (recursive vs. iterative, depth-first vs. breadth-first) are interesting to visualize. 

## Iterative, in R

```{r}
testdf <- join_pixc(rodir(18)) %>% 
  # filter(node_index %in% 300:312)
  filter()
rangeinds <- testdf$range_index
aziminds <- testdf$azimuth_index
nodeinds <- testdf$node_index
along <- adjust_along(testdf$along_reach, nodeinds)

startinds_us <- which(nodeinds == max(nodeinds))
startinds_ds <- which(nodeinds == min(nodeinds))
```



## Recursive, in Python


```{python}
import numpy as np
import sys

# sys.setrecursionlimit(100000) # allow for adequately deep recursion

rangeinds = np.array(r.rangeinds)
aziminds = np.array(r.aziminds)
rainds = np.add(rangeinds * 100000, aziminds)
rasorted = np.argsort(rainds)
along = np.array(r.along)
startinds_us = np.add(r.startinds_us, -1)
startinds_ds = np.add(r.startinds_ds, -1)
npix = len(rangeinds)

tracker = np.zeros(npix)

count = 1

def connect_recursive(ind, upstream = False):
  # print("connecting: ", ind)
  tracker[ind] = count
  count += 1
  for neighbor in stream_neighbors(ind, nnbr = 2, upstream = upstream):
    goon = ~connected[neighbor]
    connected[neighbor] = True
    if goon:
      connect_recursive(neighbor, upstream = upstream)
  return

def match_range_azim(r_inds, a_inds):
  tomatch = np.add(np.tile(r_inds * 100000, len(a_inds)),
                   np.repeat(a_inds, len(r_inds)))
  lmatch = np.searchsorted(rainds, tomatch, side='left', sorter = rasorted)
  # print(lmatch)
  rmatch = np.searchsorted(rainds, tomatch, side='right', sorter = rasorted)
  # print(rmatch)
  # print(len(rasorted))
  # print(np.max(lmatch))
  out = np.append(rasorted, 0)[lmatch]
  return out[lmatch == (rmatch - 1)]

def stream_neighbors(index, nnbr = 2, upstream = False):
  this_range = np.add(rangeinds[index], np.arange(-nnbr, nnbr + 1))
  this_azimuth = np.add(aziminds[index], np.arange(-nnbr, nnbr + 1))
  this_along = along[index]
  neighborinds = match_range_azim(this_range, this_azimuth)
  nbrmask = along[neighborinds] > this_along
  if upstream:
    nbrmask = ~nbrmask
  out_inds = neighborinds[nbrmask]
  return out_inds
  
  
connected = np.zeros(npix, dtype = bool)
connected[startinds_ds] = True

for index in startinds_ds:
  connect_recursive(index)

connected_ds = connected
recurseno_ds = tracker
print("Downstream completed")
connected = np.zeros(npix, dtype = bool)
count = 1

for index in startinds_us:
  connect_recursive(index, upstream=True)

recurseno_us = tracker
connected_us = connected
print("Upstream completed")
connected = connected_ds & connected_us

np.sum(connected)

```



